use crate::trace::display_value;
use itf::Value;
use serde::de::DeserializeOwned;
use std::fmt;

/// A single step in a trace generated by Quint.
///
/// A `Step` represents a snapshot of the system state at a particular point in
/// a trace, including state variables from your Quint specification and
/// metadata about the action that was taken. It provides methods to extract and
/// deserialize values from the trace state.
///
/// # Usage
///
/// You typically interact with `Step` in two contexts:
///
/// 1. **In `Driver::step`** - As a `&Step` reference to determine which action
///    to execute
/// 2. **In `Driver::check`** - As an owned `Step` to verify state consistency
///
/// # Extracting Values
///
/// The `Step` struct provides two main methods for extracting values:
///
/// - [`get`](Step::get) - Extract a top-level field from the state
/// - [`get_in`](Step::get_in) - Extract a nested field using a path
///
/// Both methods deserialize the value into the requested type `T`, which must
/// implement [`serde::de::DeserializeOwned`].
///
/// # Examples
///
/// ## Extracting Top-Level State Variables
///
/// ```ignore
/// // Extract a complex value with a custom type
/// #[derive(Deserialize)]
/// struct GameState {
///     score: i64,
///     lives: i64,
/// }
///
/// impl Driver for MyDriver {
///     fn check(&self, step: Step) {
///         if let Some(state) = step.get::<GameState>("gameState") {
///             assert_eq!(self.score, state.score);
///             assert_eq!(self.lives, state.lives);
///         }
///     }
/// }
/// ```
///
/// ## Extracting Nested State Variables
///
/// ```ignore
/// impl Driver for MyDriver {
///     fn check(&self, step: Step) {
///         if let Some(balance) = step.get_in::<i64>(&["accounts", "alice", "balance"]) {
///             assert_eq!(self.alice_balance, balance);
///         }
///     }
/// }
/// ```
///
/// # Type Requirements
///
/// Any type you extract from a `Step` must implement
/// [`serde::de::DeserializeOwned`]. Common types that work include:
///
/// - Primitives: `i64`, `u64`, `f64`, `bool`, `String`
/// - Collections: `Vec<T>`, `HashMap<K, V>`, `HashSet<T>`
/// - Tuples: `(A, B)`, `(A, B, C)`, etc.
/// - Custom types with `#[derive(Deserialize)]`
///
/// Note that type variants in Quint state are represented by a record with
/// `tag` and `value` fields. To deserialize them as `enum` variants in Rust,
/// please provide the necessary `serde` annotations:
///
/// ```ignore
/// // Quint: type Player = X | O
/// #[derive(Deserialize)]
/// #[serde(tag = "tag")]
/// enum Player {
///     X,
///     O,
/// }
///
/// // Quint: type Square = Occupied(Player) | Empty
/// #[derive(Deserialize)]
/// #[serde(tag = "tag", content = "value")]
/// enum Square {
///     Occupied(Player),
///     Empty,
/// }
/// ```
///
/// # Panics
///
/// The extraction methods will panic if:
///
/// - The value exists but cannot be deserialized into type `T`
/// - This typically indicates a type mismatch between your Rust code and the
///   Quint specification
///
/// If a field doesn't exist, the methods return `None` instead of panicking.
#[derive(Debug)]
pub struct Step(Value);

impl From<Value> for Step {
    fn from(value: Value) -> Self {
        Self(value)
    }
}

impl Step {
    /// Extracts a top-level field from the trace state.
    ///
    /// This method retrieves a state variable from the Quint specification and
    /// deserializes it into the requested type `T`. It's the primary way to
    /// access state values when verifying your implementation matches the
    /// specification.
    ///
    /// # Type Parameters
    ///
    /// - `T`: The type to deserialize the field into. Must implement
    ///   [`DeserializeOwned`].
    ///
    /// # Parameters
    ///
    /// - `field`: The name of the state variable from your Quint specification
    ///
    /// # Returns
    ///
    /// - `Some(value)` if the field exists and was successfully deserialized
    /// - `None` if the field doesn't exist in the trace state
    ///
    /// # Panics
    ///
    /// Panics if the field exists but cannot be deserialized into type `T`.
    /// This typically indicates a type mismatch between your Rust code and the
    /// Quint specification.
    pub fn get<T>(&self, field: &str) -> Option<T>
    where
        T: DeserializeOwned,
    {
        self.get_in(&[field])
    }

    /// Extracts a nested field from the trace state using a path.
    ///
    /// This method allows you to access deeply nested state variables by
    /// providing a path of field names. It's useful when your Quint
    /// specification has nested record structures.
    ///
    /// # Type Parameters
    ///
    /// - `T`: The type to deserialize the field into. Must implement
    ///   [`DeserializeOwned`].
    ///
    /// # Parameters
    ///
    /// - `path`: A slice of field names representing the path to the nested
    ///   value. For example, `&["user", "profile", "email"]` would access
    ///   `user.profile.email` in Quint.
    ///
    /// # Returns
    ///
    /// - `Some(value)` if the path exists and the value was successfully
    ///   deserialized
    /// - `None` if any part of the path doesn't exist
    ///
    /// # Panics
    ///
    /// Panics if the path exists but the final value cannot be deserialized
    /// into type `T`.
    pub fn get_in<T>(&self, path: &[&str]) -> Option<T>
    where
        T: DeserializeOwned,
    {
        if let Some(value) = self.get_value_in(path) {
            let decoded = T::deserialize(value.clone()).expect("failed to decode state value");
            return Some(decoded);
        }
        None
    }

    pub(crate) fn get_value(&self, field: &str) -> Option<&Value> {
        self.get_value_in(&[field])
    }

    pub(crate) fn get_value_in(&self, path: &[&str]) -> Option<&Value> {
        let mut value: Option<&Value> = Some(&self.0);

        for segment in path {
            if let Value::Record(rec) = value.unwrap() {
                value = rec.get(segment);
                if value.is_none() {
                    break;
                }
            }
        }

        value
    }
}

impl fmt::Display for Step {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(Value::Record(rec)) = self.get_value_in(&[]) {
            for (key, value) in rec.iter() {
                // FIXME: it seems error prone to filter variables here. We
                // should extract metadata variables out of the state Value and
                // handle them properly.
                if !key.starts_with("mbt::") {
                    write!(f, "     + {}: ", key)?;
                    display_value(f, value)?;
                    writeln!(f)?;
                }
            }
        } else {
            display_value(f, &self.0)?;
        }
        Ok(())
    }
}
