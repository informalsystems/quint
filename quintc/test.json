{"stage":"documentation","warnings":[],"documentation":[{"header":"pureval Nat: Set[int] = undefined","description":"The infinite set of all natural numbers\n\nSome operators cannot be applied to inifine sets."},{"header":"pureval Int: Set[int] = undefined","description":"The infinite set of all integers\n\nSome operators cannot be applied to inifine sets."},{"header":"pureval Bool: Set[bool] = undefined","description":"The set of all booleans\nThat is, Set(false, true)"},{"header":"puredef eq: (t, t) => bool = (a, b => undefined)","description":"`a.eq(b)` is `true` when `a` and `b` are equal values of the same type.\nIt can be used in the infix form as `==` or as a named operator `eq`."},{"header":"puredef neq: (t, t) => bool = (a, b => undefined)","description":"`a.neq(b)` is `true` when `a` and `b` are not equal values of the same type.\nIt can be used in the infix form as `!=` or as a named operator `neq`."},{"header":"puredef reserved: (bool, bool) => bool = (p, q => undefined)","description":"`p.iff(q)` is `true` when `p` and `q` are equal values of the bool type.\n\nThis is the logical equivalence operator.\n\n# Examples\n\n```\nassert(iff(true, true))\nassert(iff(false, false))\nassert(not(iff(true, false)))\nassert(not(iff(false, true)))\n```"},{"header":"puredef reserved: (bool, bool) => bool = (p, q => undefined)","description":"`p.implies(q)` is true when `not(p) or q` is true.\n\nThis is the material implication operator.\n\n# Examples\n\n```\nassert(true.implies(true))\nassert(false.implies(false))\nassert(not(true.implies(false)))\nassert(not(false.implies(true)))\n```"},{"header":"puredef not: (bool) => bool = (a => undefined)","description":"`not(p)` is `true` when `p` is `false`. \n\nThis is the negation opearator."},{"header":"puredef guess: (Set[a], (a) => bool) => bool = (a, p => undefined)","description":"Guess a value from the given set that satisfies the given predicate.\nThis operator is non-deterministic.\n\nIf the set is empty, then the result is `false`.\n\n# Examples\n```\nvar x: int\nrun a = Set(1, 2, 3).guess(n => x' = n).then(assert(x.in(Set(1, 2, 3))))\n```"},{"header":"puredef exists: (Set[a], (a) => bool) => bool = (a, p => undefined)","description":"`s.exists(p)` is true when there is an element in `s` that satisfies `p`.\n\nThis is the existential quantifier.\n\n# Examples\n```\nassert(Set(1, 2, 3).exists(n => n == 2))\nassert(not(Set(1, 2, 3).exists(n => n == 4)))\n```"},{"header":"puredef forall: (Set[a], (a) => bool) => bool = (a, p => undefined)","description":"`s.forall(p)` is true when all elements in `s` satisfy `p`.\n\nThis is the universal quantifier.\n\n# Examples\n```\nassert(Set(1, 2, 3).forall(n => n > 0))\nassert(not(Set(1, 2, 3).forall(n => n > 1)))\n```"},{"header":"puredef in: (a, Set[a]) => bool = (a, s => undefined)","description":"`e.in(s)` is true when the element `e` is in the set `s`.\n\nThis is the set membership relation.\nSee also: `contains` \n\n# Examples\n```\nassert(1.in(Set(1, 2, 3)))\nassert(not(4.in(Set(1, 2, 3))))\n```"},{"header":"puredef contains: (Set[a], a) => bool = (a, s => undefined)","description":"`s.contains(e)` is true when the element `e` is in the set `s`.\n\nThis is the set membership relation.\nSee also: `in` \n\n# Examples\n```\nassert(Set(1, 2, 3).contains(1))\nassert(not(Set(1, 2, 3).contains(4)))\n```"},{"header":"puredef notin: (a, Set[a]) => bool = (a, s => undefined)","description":"`e.notin(s)` is true when the element `e` is not in the set `s`.\n\nSee also: `in`\n\n# Examples\n```\nassert(4.notin(Set(1, 2, 3)))\nassert(not(1.notin(Set(1, 2, 3))))\n```"},{"header":"puredef union: (Set[a], Set[a]) => Set[a] = (s1, s2 => undefined)","description":"`s1.union(s2)` is the set of elements that are in `s1` or in `s2`.\n\nThis is the set union operator.\n\n# Examples\n```\nassert(Set(1, 2, 3).union(Set(2, 3, 4)) == Set(1, 2, 3, 4))\n```"},{"header":"puredef intersect: (Set[a], Set[a]) => Set[a] = (s1, s2 => undefined)","description":"`s1.intersect(s2)` is the set of elements that are in both sets `s1` and `s2`.\n\nThis is the set intersection operator.\n\n# Examples\n```\nassert(Set(1, 2, 3).intersect(Set(2, 3, 4)) == Set(2, 3))\n```"},{"header":"puredef exclude: (Set[a], Set[a]) => Set[a] = (s1, s2 => undefined)","description":"`s1.exclude(s2)` is the set of elements in `s1` that are not in `s2`.\n\nThis is the set difference operator.\n\n# Examples\n```\nassert(Set(1, 2, 3).exclude(Set(2, 3, 4)) == Set(1))\n```"},{"header":"puredef subseteq: (Set[a], Set[a]) => bool = (s1, s2 => undefined)","description":"`s1.subseteq(s2)` is true when all elements in `s1` are also in `s2`. \n\n# Examples\n```\nassert(Set(1, 2, 3).subseteq(Set(1, 2, 3, 4)))\nassert(not(Set(1, 2, 3).subseteq(Set(1, 2))))\n```"},{"header":"puredef filter: (Set[a], (a) => bool) => Set[a] = (s, p => undefined)","description":"`s.filter(p)` is the set of elements in `s` that satisfy `p`. \n\n# Examples\n```\nassert(Set(1, 2, 3).filter(n => n > 1) == Set(2, 3))\n```"},{"header":"puredef map: (Set[a], (a) => b) => Set[b] = (s, f => undefined)","description":"`s.map(f)` is the set of elements obtained by applying `f` to  \nto each element in `s`. I.e., `{ f(x) : x \\in s}`.\n\n# Examples\n```\nassert(Set(1, 2, 3).map(n => n > 1) == Set(false, true, true))\n```"},{"header":"puredef fold: (Set[a], b, (b, a) => b) => b = (s, v, f => undefined)","description":"`s.fold(z, f)` is the result of applying `f` to `z` and each element in `s`.\nI.e., `f(...f(f(z, x0), x1)..., xn)`.\nThe order in which the elements are combined is unspecified, so\nthe operator must be associative and commutative or else it has undefined behavior.\n\n# Examples\n```\nval sum = Set(1, 2, 3, 4).fold(0, (x, y) => x + y)\nassert(sum == 10)\nval mul = Set(1, 2, 3, 4).fold(1, (x, y) => x * y)\nassert(mul == 24)\n```"},{"header":"puredef powerset: (Set[Set[a]]) => Set[Set[a]] = (s => undefined)","description":"`s.powerset()` is the set of all subsets of `s`,\nincluding the empty set and the set itself.\n\n# Examples\n```\nassert(Set(1, 2).powerset() == Set(\n  Set(),\n  Set(1),\n  Set(2),\n  Set(1, 2)\n))\n```"},{"header":"puredef flatten: (Set[Set[a]]) => Set[a] = (s => undefined)","description":"`s.flatten()` is the set of all elements in the sets in `s`.\n\n# Examples\n```\nassert(Set(Set(1, 2), Set(3, 4)).flatten() == Set(1, 2, 3, 4))\n```"},{"header":"puredef allLists: (Set[a]) => Set[List[a]] = (s => undefined)","description":"`s.allLists()` is the set of all lists containing all the elements in `s`.\n\n# Examples\n```\nassert(Set(1, 2).allLists() == Set(\n  List(1, 2),\n  List(2, 1),\n)) \n```"},{"header":"puredef chooseSome: (Set[a]) => a = (s => undefined)","description":"`s.chooseSome()` is, deterministically, one element of `s`.\n\n# Examples\n```\nassert(Set(1, 2, 3).chooseSome() == 1)\nassert(Set(1, 2, 3).filter(x => x > 2).chooseSome() == 3)\n```"},{"header":"puredef oneOf: (Set[a]) => a = (s => undefined)","description":"`s.oneOf()` is, non-deterministically, one element of `s`.\n\n# Examples\n```\nnondet x = oneOf(Set(1, 2, 3))\nassert(x.in(Set(1, 2, 3)))\n```"},{"header":"puredef isFinite: (Set[a]) => bool = (s => undefined)","description":"`s.isFinite()` is true when `s` is a finite set\n\n# Examples\n```\nassert(Set(1, 2, 3).isFinite())\nassert(!Nat.isFinite())\n```"},{"header":"puredef size: (Set[a]) => int = (s => undefined)","description":"`s.size()` is the cardinality of `s`.\n\n# Examples\n```\nassert(Set(1, 2, 3).size() == 3)\n```"},{"header":"puredef get: ((a -> b), a) => b = (a, b => undefined)","description":"`m.get(k)` is the value for `k` in `m`.\nIf `k` is not in `m` then the behavior is undefined.\n\n# Examples\n\n```\npure val m = Map(1 -> true, 2 -> false)\nassert(m.get(1) == true)\n```"},{"header":"puredef keys: ((a -> b)) => Set[a] = (a => undefined)","description":"`m.keys()` is the set of keys in the map `m`.\n\n# Examples\n\n```\npure val m = Map(1 -> true, 2 -> false)\nassert(m.keys() == Set(1, 2))\n```"},{"header":"puredef mapBy: (Set[a], (a) => b) => (a -> b) = (s, f => undefined)","description":"`s.mapBy(f)` is the map from `x` to `f(x)` for each element `x` in `s`.\n\n# Examples\n\n```\npure val m = Set(1, 2, 3).mapBy(x => x * x)\nassert(m == Map(1 -> 1, 2 -> 4, 3 -> 9))\n```"},{"header":"puredef setToMap: (Set[(a, b)]) => (a -> b) = (s => undefined)","description":"`s.setToMap()` for a set of pairs `s` is the map \nfrom the first element of each pair to the second.\n\n# Examples\n\n```\npure val m = Set((1, true), (2, false)).setToMap()\nassert(m == Map(1 -> true, 2 -> false))\n```"},{"header":"puredef setOfMaps: (Set[a], Set[b]) => Set[(a -> b)] = (s1, s2 => undefined)","description":"Creates a set of all possible maps from a set of keys to a set of values.\n`keys.setOfMaps(values)` is the set of all maps from `keys` to `values`.\n\n# Examples\n\n```\npure val s = Set(1, 2).setOfMaps(set(true, false))\nassert(s == Set(\n  Map(1 -> true, 2 -> true),\n  Map(1 -> true, 2 -> false),\n  Map(1 -> false, 2 -> true),\n  Map(1 -> false, 2 -> false),\n))\n```"},{"header":"puredef set: ((a -> b), a, b) => (a -> b) = (m, k, v => undefined)","description":"`m.set(k, v)` for `k.in(m.keys)` is a map with the same keys as `m` but with `k` set to `v`.\nIf `k` is not present in `m`, this operator has undefined behavior.\n\n# Examples\n\n```\npure val m = Map(1 -> true, 2 -> false)\npure val m2 = m.set(2, true)\nassert(m == Map(1 -> true, 2 -> false))\nassert(m2 == Map(1 -> true, 2 -> true))\n```"},{"header":"puredef setBy: ((a -> b), a, (b) => b) => (a -> b) = (m, k, v => undefined)","description":"`m.setBy(k, f)` is a map with the same keys as `m` but with `k` set to `f(m.get(k))`.\nIf `k` is not present in `m`, this operator has undefined behavior.\n\n# Examples\n\n```\npure val m = Map(1 -> true, 2 -> false)\npure val m2 = m.setBy(2, x => !x)\nassert(m == Map(1 -> true, 2 -> false))\nassert(m2 == Map(1 -> true, 2 -> true))\n```"},{"header":"puredef put: ((a -> b), a, b) => (a -> b) = (m, k, v => undefined)","description":"`m.put(k, v)` for `k.notin(m.keys)` is a map with the same keys as `m` but with `k` set to `v`.\nIf `k` is present in `m`, this operator has undefined behavior.\n\n# Examples\n\n```\npure val m = Map(1 -> true, 2 -> false)\npure val m2 = m.put(3, true)\nassert(m == Map(1 -> true, 2 -> false))\nassert(m2 == Map(1 -> true, 2 -> false, 3 -> true))\n```"},{"header":"puredef append: (List[a], a) => List[a] = (l, e => undefined)","description":"`l.append(e)` is the list `l` with `e` appended.\n\n# Examples\n\n```\nassert(List(1, 2, 3).append(4) == List(1, 2, 3, 4))\n```"},{"header":"puredef concat: (List[a], List[a]) => List[a] = (l1, l2 => undefined)","description":"`l1.concat(l2)` is the list `l1` with `l2` concatenated at the end.\n\n# Examples\n\n```\nassert(List(1, 2, 3).append(List(4, 5, 6)) == List(1, 2, 3, 4, 5, 6))\n```"},{"header":"puredef head: (List[a]) => a = (l => undefined)","description":"`l.head()` is the first element of `l`.\nIf `l` is empty, the behavior is undefined.\n\n# Examples\n\n```\nassert(List(1, 2, 3).head() == 1)\n```"},{"header":"puredef tail: (List[a]) => List[a] = (l => undefined)","description":"`l.tail()` is the list `l` without the first element.\nIf `l` is empty, the behavior is undefined.\n\n# Examples\n\n```\nassert(List(1, 2, 3).tail() == List(2, 3))\n```"},{"header":"puredef length: (List[a]) => int = (l => undefined)","description":"`l.length()` is the length of the list `l`.\n\n# Examples\n\n```\nassert(List(1, 2, 3).length() == 3)\n```"},{"header":"puredef nth: (List[a], int) => a = (l, i => undefined)","description":"`l.nth(i)` is the `i+1`th element of the list `l`.\nIf `i` is negative or greater than or equal to `l.length()`, the behavior is undefined.\n\n# Examples\n\n```\nassert(List(1, 2, 3).nth(1) == 2)\n```"},{"header":"puredef indices: (List[a]) => Set[int] = (l => undefined)","description":"`l.indices()` is the set of indices of `l`.\n\n# Examples\n\n```\nassert(List(1, 2, 3).indices() == Set(0, 1, 2))\n```"},{"header":"puredef replaceAt: (List[a], int, a) => List[a] = (l, i, e => undefined)","description":"`l.replaceAt(i, e)` is the list `l` with the `i+1`th element replaced by `e`.\nIf `i` is negative or greater than or equal to `l.length()`, the behavior is undefined.\n\n# Examples\n\n```\nassert(List(1, 2, 3).replaceAt(1, 4) == List(1, 4, 3))\n```"},{"header":"puredef slice: (List[a], int, int) => List[a] = (l, i, j => undefined)","description":"`l.slice(i, j)` is the list of elements of `l` between indices `i` and `j`.\n`i` is inclusive and `j` is exclusive.\n\nThe behavior is undefined when:\n- `i` is negative or greater than or equal to `l.length()`.\n- `j` is negative or greater than `l.length()`.\n- `i` is greater than `j`.\n\n# Examples\n\n```\nassert(List(1, 2, 3, 4, 5).slice(1, 3) == List(2, 3))\n```"},{"header":"puredef range: (int, int) => List[int] = (i, j => undefined)","description":"`range(i, j)` is the list of integers between `i` and `j`.\n`i` is inclusive and `j` is exclusive.\n\nThe behavior is undefined when `i` is greater than `j`.\n\n# Examples\n\n```\nassert(range(1, 3) == List(1, 2))\n```"},{"header":"puredef select: (List[a], (a) => bool) => List[a] = (l, p => undefined)","description":"`l.select(p)` is the list of elements of `l` that satisfy the predicate `p`.\n\nPreserves the order of the elements.\n\n# Examples\n\n```\nassert(List(1, 2, 3).select(x -> x % 2 == 0) == List(2))\n```"},{"header":"puredef foldl: (List[a], b, (b, a) => b) => b = (l, z, f => undefined)","description":"`l.foldl(z, f)` is the result of applying `f` to `z` and each element in `s`.\nI.e., `f(f(f(z, x0), x1)..., xn)`.\n\n# Examples\n```\npure val sum = List(1, 2, 3, 4).foldl(0, (x, y) => x + y)\nassert(sum == 10)\npure val l = List(1, 2, 3, 4).foldl(List(), (l, e) => l.append(e))\nassert(l == List(1, 2, 3, 4))\n```"},{"header":"puredef foldr: (List[a], b, (a, b) => b) => b = (l, z, f => undefined)","description":"`l.foldr(z, f)` is the result of applying `f` to each element in `s` and `z`.\nI.e., `f(x0, f(x1, ... f(xn, z))`.\n\n# Examples\n```\npure val sum = List(1, 2, 3, 4).foldr(0, (x, y) => x + y)\nassert(sum == 10)\npure val l = List(1, 2, 3, 4).foldr(List(), (e, l) => l.append(e))\nassert(l == List(4, 3, 2, 1))\n```"},{"header":"puredef iadd: (int, int) => int = (a, b => undefined)","description":"`a.iadd(b)` is the integer addition of `a` and `b`.\nIt can be used in the infix form as `+` or as a named operator `iadd`."},{"header":"puredef isub: (int, int) => int = (a, b => undefined)","description":"`a.isub(b)` is the integer subtraction of `a` and `b`.\nIt can be used in the infix form as `-` or as a named operator `isub`."},{"header":"puredef imul: (int, int) => int = (a, b => undefined)","description":"`a.imul(b)` is the integer multiplication of `a` and `b`.\nIt can be used in the infix form as `*` or as a named operator `imul`."},{"header":"puredef idiv: (int, int) => int = (a, b => undefined)","description":"`a.idiv(b)` is the integer division of `a` and `b`.\nIt can be used in the infix form as `/` or as a named operator `idiv`."},{"header":"puredef imod: (int, int) => int = (a, b => undefined)","description":"`a.imod(b)` is the integer modulus of `a` and `b`.\nIt can be used in the infix form as `%` or as a named operator `imod`."},{"header":"puredef ipow: (int, int) => int = (a, b => undefined)","description":"`a.ipow(b)` is the integer exponentiation of `a` and `b`.\nIt can be used in the infix form as `^` or as a named operator `ipow`."},{"header":"puredef ilt: (int, int) => bool = (a, b => undefined)","description":"`a.ilt(b)` is the integer less than comparison of `a` and `b`.\nIt can be used in the infix form as `<` or as a named operator `ilt`."},{"header":"puredef igt: (int, int) => bool = (a, b => undefined)","description":"`a.igt(b)` is the integer greater than comparison of `a` and `b`.\nIt can be used in the infix form as `>` or as a named operator `igt`."},{"header":"puredef ilte: (int, int) => bool = (a, b => undefined)","description":"`a.ilte(b)` is the integer less than or equal to comparison of `a` and `b`.\nIt can be used in the infix form as `<=` or as a named operator `ilte`."},{"header":"puredef igte: (int, int) => bool = (a, b => undefined)","description":"`a.igte(b)` is the integer greater than or equal to comparison of `a` and `b`.\nIt can be used in the infix form as `>=` or as a named operator `igte`."},{"header":"puredef iuminus: (int) => int = (a => undefined)","description":"`iuminus(a)` is `-1 * a`.\n\nThis is the unary minus operator"},{"header":"puredef to: (int, int) => Set[int] = (i, j => undefined)","description":"`i.to(j)` is the set of integers between `i` and `j`.\n`i` is inclusive and `j` is exclusive.\n\nThe behavior is undefined when `i` is greater than `j`.\n\n# Examples\n\n```\nassert(1.to(3) == Set(1, 2))\n```"},{"header":"temporal always: (bool) => bool = (p => undefined)","description":"`always(p)` is true when `p` is true for every transition of the system.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next = x' = x + 1\ntemporal Property = always(next(x) > x) \n```"},{"header":"temporal eventually: (bool) => bool = (a => undefined)","description":"`eventually(p)` is true when `p` is true for some transition of the system.\n\n`eventually(p)` is equivalent to `not(always(not(p)))`.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next = x' = x + 1\ntemporal Property = eventually(x == 10) \n```"},{"header":"temporal next: (a) => a = (a => undefined)","description":"`next(a)` is the value of `a` in the next state of a transition.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next = x' = x + 1\ntemporal Property = next(x) == x + 1\n```"},{"header":"temporal orKeep: (bool, a) => bool = (a, v => undefined)","description":"`orKeep(a, v)` is true when `a` is true or the values for the set of variables `v` are unchanged.\n\n`orKeep(a, v)` is equivalent to `a or v.map(x => next(x) = x)`.\nThis is the stuttering operator.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next =  x' = x + 1\ntemporal Spec = Init and always(Next.orKeep(Set(x)))\n```"},{"header":"temporal mustChange: (bool, a) => bool = (a, v => undefined)","description":"`mustChange(a, v)` is true when `a` is true and the values for the set of variables `v` are changed.\n\n`mustChange(a, v)` is equivalent to `a and v.map(x => next(x) != x)`.\nThis is the no-stuttering operator.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next = any {\n  x' = x + 1,\n  x' = x,\n}\ntemporal Spec = Init and always(Next.mustChange(Set(x)))\ntemporal Property = Spec.implies(always(next(x) > x))\n```"},{"header":"temporal enabled: (bool) => bool = (a => undefined)","description":"`enabled(a)` is true when the action `a` is enabled in the current state.\nAn action is enabled when all its preconditions are satisfied.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Under10 = all {\n  x < 10,\n  x' = x + 1,\n}\naction Over10 = all {\n  x >= 10,\n  x' = x + 1,\n}\ntemporal Property = always(or {  \n  x < 10 and enabled(Under10),\n  x >= 10 and enabled(Over10), \n})\n```"},{"header":"temporal weakFair: (bool, a) => bool = (a, b => undefined)","description":"`weakFair(a, v)` is true when `eventually(always(a.mustChange(v).enabled())).implies(always(eventually(a.mustChange(v))))` is true.\n\nThis is the weak fairness condition.\nThe weak fairness condition can be expressed in English as (from Specifying Systems):\n1. It’s always the case that, if A is enabled forever, then an A step eventually occurs.\n2. A is infinitely often disabled, or infinitely many A steps occur.\n3. If A is eventually enabled forever, then infinitely many A steps occur.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction Next = any {\n  x' = x + 1,\n  x' = x,\n}\n\ntemporal Property = Next.weakFair(Set(x)).implies(eventually(x == 10))\n```"},{"header":"temporal strongFair: (bool, a) => bool = (a, b => undefined)","description":"`strongFair(a, v)` is true when `always(eventually(a.mustChange(v).enabled())).implies(always(eventually(a.mustChange(v))))` is true.\n\nThis is the strong fairness condition.\nThe strong fairness condition can be expressed in English as (from Specifying Systems):\n1. A is eventually disabled forever, or infinitely many A steps occur.\n2. If A is infinitely often enabled, then infinitely many A steps occur.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\naction cycleTo1 = all { x == 0, x' = 1 },\naction cycleTo0 = all { x == 1, x' = 0 },\naction breakCycle = all { x == 0, x' = 2 },\n\naction Next = any {\n cycleTo1,\n cycleTo0,\n breakCycle,\n x' = x,\n}\n\n// Strong fairness can be used to ensure breakCycle happens\ntemporal Property = breakCycle.strongFair(Set(x)).implies(eventually(x == 2))"},{"header":"action assign: (a, a) => bool = (n, v => undefined)","description":"`assign(n, v)` is true when the state variable named `n` has the value `v` in the next state of a transition.\nThis is the main operator to define transitions.\n\nCan be written as `n' = v`.\n\n# Examples\n\n```\nvar x: int\naction Init = x' = 0\n// Next defines all transitions from a number to its successor.\naction Next = x' = x + 1\n```"},{"header":"action ite: (bool, a, a) => a = (c, t, e => undefined)","description":"`ite(c, t, e)` is `t` when `c` is true and `e` when `c` is false.\n\nCan be written as `if (c) t else e`.\nCan be used with actions.\n\n# Examples\n\n```\npure val m = if (1 == 2) 3 else 4\nassert(m == 4)\n```\n\n```\nvar x: int\naction a = if (x == 0) x' = 3 else x' = 4\nrun test = (x' = 0).then(a).then(assert(x == 3))\n```"},{"header":"action then: (bool, bool) => bool = (a, b => undefined)","description":"`a.then(b)` is true for a step from `s1` to `s2` if there is a state `t` such that \n`a` is true for a step from `s1` to `t` and `b` is true for a step from `t` to `s2`.\n\nThis is the action composition operator.\n\n# Examples\n\n```\nvar x: int\nrun test = (x' = 1).then(x' = 2).then(x' = 3).then(assert(x == 3))\n```"},{"header":"action times: (int, bool) => bool = (n, a => undefined)","description":"`n.times(a)` is the action `a` repeated `n` times.\n\nThe semantics of this operator is as follows:\n- When `n <= 0`, this operator does not change the state.\n- When `n = 1`, `n.times(a)` is equivalent to `a`.\n- When `n > 1`, `n.times(a)`, is equivalent to `a.then((n - 1).times(a))`.\n\nNote that the operator `n.times(a)` applies `a` exactly `n` times (when `n` is\nnon-negative). If you want to repeat `a` from `i` to `j` times, you can combine\nit with `orKeep`:\n\n```\ni.times(a).then((j - i).times(a.orKeep(vars)))\n```\n\n# Examples\n\n```\nvar x: int\nrun test = (x' = 0).then(3.times(x' = x + 1)).then(assert(x == 3))\n```"},{"header":"action assert: (bool) => bool = (p => undefined)","description":"`assert(p)` is an action that is true when `p` is true.\nIt does not change the state.\n\n# Examples\n\n```\nvar x: int\nrun test = (x' = 0).then(3.times(x' = x + 1)).then(assert(x == 3))\n```\n\n```\nvar x: int\naction Init = x' = 0\naction Next = x' = x + 1\n\nrun test = Init.then(all { Next, assert(x > 0) })\n```"},{"header":"puredef field: ({ f: a | r }, str) => a = (r, f => undefined)","description":"`r.field(f)` is the value of the field `f` in the record `r`.\n\nThis is the record projection operator.\nCan also be written as `r.f`.\n\n# Examples\n\n```\npure val r = { x: 1, y: 2 }\nassert(r.field(\"x\") == 1)\nassert(r.y == 1)\n```"}]}