module Paxos {
/***************************************************************************
 * This is a specification of the Paxos algorithm without explicit leaders *
 * or learners.  It refines the spec in Voting                             *
 ***************************************************************************/
/***************************************************************************
 * The constant parameters and the set Ballots are the same as in Voting.  *
 ***************************************************************************/

const Value: set(int)

const Acceptor: set(str)

const Quorum: set(set(str))

assume _ = (
    & Quorum.forall(Q => Q.subseteq(Acceptor))
    & tuples(Quorum, Quorum).forall(t => (t._1.intersect(t._2)) != set())
)
      
val Ballot = Nat

val None = -1
  /*************************************************************************
   * An unspecified value that is not a ballot number.                     *
   *************************************************************************/
  
/***************************************************************************
 * This is a message-passing algorithm, so we begin by defining the set    *
 * Message of all possible messages.  The messages are explained below     *
 * with the actions that send them.                                        *
 ***************************************************************************/
val Message =
    val M1a =
      Ballot.map(b => { tag: "1a", bal: b })

    val M1b =
      tuples(Acceptor, Ballot, union(Ballot, set(-1)), union(Value, set(None)))
        .map(t => { tag: "1b", acc: t._1, bal: t._2, mbal: t._3, mval: t._4 })

    val M2a =
      tuples(Ballot, Value)
        .map(t => { tag: "2a", bal: t._1, value: t._2 })

    val M2b =
      tuples(Acceptor, Ballot, Value)
        .map(t => { tag: "2b", acc: t._1, bal: t._2, value: t._3 })

    M1a.union(M1b).union(M2a).union(M2b)
//-----------------------------------------------------------------------------

var maxBal:   int
var maxVBal:  int // <<maxVBal[a], maxVal[a]>> is the vote with the largest
var maxVal:   str -> int  // ballot number cast by a; it equals <<-1, None>> if
                          // a has not cast any vote.

// A union type for records (not supported by Apalache yet, see #789).
// It is just a type, and it is less precise than the set Message.
type MSGS =
    | { tag: "1a", bal: int }
    | { tag: "1b", acceptor: str, bal: int, mbal: int, mval: int }
    | { tag: "2a", bal: int, value: int }
    | { tag: "2b", acc: str, bal: int, value: int }

var msgs: MSGS // The set of all messages that have been sent.

/***************************************************************************)
(* NOTE:                                                                   *)
(* The algorithm is easier to understand in terms of the set msgs of all   *)
(* messages that have ever been sent.  A more accurate model would use     *)
(* one or more variables to represent the messages actually in transit,    *)
(* and it would include actions representing message loss and duplication  *)
(* as well as message receipt.                                             *)
(*                                                                         *)
(* In the current spec, there is no need to model message loss because we  *)
(* are mainly concerned with the algorithm's safety property.  The safety  *)
(* part of the spec says only what messages may be received and does not   *)
(* assert that any message actually is received.  Thus, there is no        *)
(* difference between a lost message and one that is never received.  The  *)
(* liveness property of the spec that we check makes it clear what         *)
(* messages must be received (and hence either not lost or successfully    *)
(* retransmitted if lost) to guarantee progress.                           *)
(***************************************************************************/

val vars = (maxBal, maxVBal, maxVal, msgs)
  /************************************************************************* 
   * It is convenient to define some identifier to be the tuple of all     * 
   * variables.  I like to use the identifier `vars'.                      * 
   *************************************************************************/

/***************************************************************************)
(* The type invariant and initial predicate.                               *)
(***************************************************************************/
val TypeOK = (
    & maxBal  in Acceptor.setOfMaps(Ballot.union(set(-1)))
    & maxVBal in Acceptor.setOfMaps(Ballot.union(set(-1)))
    & maxVal  in Acceptor.setOfMaps(Value.union(set(None)))
    & msgs.subseteq(Message)
)

action Init = {
    & maxBal  <- Acceptor.mapOf(_ => -1)
    & maxVBal <- Acceptor.mapOf(_ => -1)
    & maxVal  <- Acceptor.mapOf(_ => None)
    & msgs    <- set()
}

/***************************************************************************)
(* The actions.  We begin with the subaction (an action that will be used  *)
(* to define the actions that make up the next-state action.               *)
(***************************************************************************/
action Send(m) = {
  msgs <- msgs.union(set(m))
}

/***************************************************************************)
(* In an implementation, there will be a leader process that orchestrates  *)
(* a ballot.  The ballot b leader performs actions Phase1a(b) and          *)
(* Phase2a(b).  The Phase1a(b) action sends a phase 1a message (a message  *)
(* m with m.type = "1a") that begins ballot b.                             *)
(***************************************************************************/
action Phase1a(b) = {
    & Send({ tag: "1a", bal: b })
    & maxVBal <- maxVBal
    & maxVal <- maxVal
}
                 
/***************************************************************************)
(* Upon receipt of a ballot b phase 1a message, acceptor a can perform a   *)
(* Phase1b(a) action only if b > maxBal[a].  The action sets maxBal[a] to  *)
(* b and sends a phase 1b message to the leader containing the values of   *)
(* maxVBal[a] and maxVal[a].                                               *)
(***************************************************************************/
action Phase1b(a) = {
    msgs.filter(m => m.tag == "1a")
        .guess({ m => {
      & m.bal > maxBal[a]
      & maxBal <- maxBal.update(a, m.bal)
      & Send({ tag: "1b", acc: a, bal: m.bal, 
               mbal: maxVBal[a], mval: maxVal[a] })
      & maxVBal <- maxVBal
      & maxVal <- maxVal
    }})
}

/***************************************************************************)
(* The Phase2a(b, v) action can be performed by the ballot b leader if two *)
(* conditions are satisfied: (i) it has not already performed a phase 2a   *)
(* action for ballot b and (ii) it has received ballot b phase 1b messages *)
(* from some quorum Q from which it can deduce that the value v is safe at *)
(* ballot b.  These enabling conditions are the first two conjuncts in the *)
(* definition of Phase2a(b, v).  This second conjunct, expressing          *)
(* condition (ii), is the heart of the algorithm.  To understand it,       *)
(* observe that the existence of a phase 1b message m in msgs implies that *)
(* m.mbal is the highest ballot number less than m.bal in which acceptor   *)
(* m.acc has or ever will cast a vote, and that m.mval is the value it     *)
(* voted for in that ballot if m.mbal # -1.  It is not hard to deduce from *)
(* this that the second conjunct implies that there exists a quorum Q such *)
(* that ShowsSafeAt(Q, b, v) (where ShowsSafeAt is defined in module       *)
(* Voting).                                                                *)
(*                                                                         *)
(* The action sends a phase 2a message that tells any acceptor a that it   *)
(* can vote for v in ballot b, unless it has already set maxBal[a]         *)
(* greater than b (thereby promising not to vote in ballot b).             *)
(***************************************************************************/
action Phase2a(b, v) = {
  & not(msgs.filter(m => m.tag == "2a")
            .exists(m => m.bal == b))
  & Quorum.exists(Q =>
        val Q1b = msgs.filter(m => m.tag == "1b")
                      .filter(m => (
                            & m.acc in Q
                            & m.bal == b
                            ))
        val Q1bv = Q1b.filter(m => m.mbal >= 0)
        {
            & Q.forall(a => Q1b.exists(m => m.acc == a))
            & (
                | Q1bv == set()
                | Q1bv.exists(m => (
                    & m.mval == v
                    & Q1bv.forall( mm => m.mbal >= mm.mbal )
                  ) )
              )
        }
     )
  & Send({ tag: "2a", bal: b, value: v })
  & maxVBal <- maxVBal
  & maxVal <- maxVal
}
  
/***************************************************************************)
(* The Phase2b(a) action is performed by acceptor a upon receipt of a      *)
(* phase 2a message.  Acceptor a can perform this action only if the       *)
(* message is for a ballot number greater than or equal to maxBal[a].  In  *)
(* that case, the acceptor votes as directed by the phase 2a message,      *)
(* setting maxVBal[a] and maxVal[a] to record that vote and sending a      *)
(* phase 2b message announcing its vote.  It also sets maxBal[a] to the    *)
(* message's.  ballot number                                               *)
(***************************************************************************/
action Phase2b(a) = msgs.filter(m => m.tag == "2a")
                        .guess({ m => {
                              & m.bal >= maxBal[a]
                              & maxBal  <- maxBal.update(a, m.bal)
                              & maxVBal <- maxVBal.update(a, m.bal)
                              & maxVal  <- maxVal.update(a, m.value)
                              & Send({ tag: "2b", acc: a,
                                       bal: m.bal, value: m.value })
}})

/***************************************************************************)
(* In an implementation, there will be learner processes that learn from   *)
(* the phase 2b messages if a value has been chosen.  The learners are     *)
(* omitted from this abstract specification of the algorithm.              *)
(***************************************************************************/

/***************************************************************************)
(* Below are defined the next-state action and the complete spec.          *)
(***************************************************************************/
action Next = {
        | { & Ballot.guess({ b => {
                            | Phase1a(b)
                            | Value.guess({ v => Phase2a(b, v) })
                       }})
            & maxBal <- maxBal
          }           

        | Acceptor.guess({ a => { Phase1b(a) | Phase2b(a) } })
}

temporal Spec = Init and always(stutter(Next, vars))
//----------------------------------------------------------------------------
/***************************************************************************)
(* We now define the refinement mapping under which this algorithm         *)
(* implements the specification in module Voting.                          *)
(***************************************************************************/

/***************************************************************************)
(* As we observed, votes are registered by sending phase 2b messages.  So  *)
(* the array `votes' describing the votes cast by the acceptors is defined *)
(* as follows.                                                             *)
(***************************************************************************/
val votes = Acceptor.mapOf( a =>
           msgs.filter(mm => mm.tag == "2b")
               .filter(mm => mm.acc == a)
               .map(m => (m.bal, m.value))
)
/***************************************************************************)
(* We now instantiate module Voting, substituting the constants Value,     *)
(* Acceptor, and Quorum declared in this module for the corresponding      *)
(* constants of that module Voting, and substituting the variable maxBal   *)
(* and the defined state function `votes' for the correspondingly-named    *)
(* variables of module Voting.                                             *)
(***************************************************************************/

// Temp fix for integration tests: mock voting definitions while files are not imported
module Voting {
  def ShowsSafeAt = 1
  val Inv = true
}

module V = Voting(*)

// Like theorems? Then you should definitely go straight for TLA+
// THEOREM Spec => V!Spec
//-----------------------------------------------------------------------------
/***************************************************************************)
(* Here is a first attempt at an inductive invariant used to prove this    *)
(* theorem.                                                                *)
(***************************************************************************/
val Inv = (
       & TypeOK
       & Acceptor.forall( a =>
           if (maxVBal[a] == -1)
           maxVal[a] == None
           else (maxVBal[a], maxVal[a]) in votes[a]
         )
       & msgs.filter(m => m.tag == "1b")
             .forall(m =>
                (maxBal[m.acc] >= m.bal
                    and ((m.mbal >= 0) implies (m.mbal, m.mval) in votes[m.acc]))
              )
       & val M2as = msgs.filter( m => m.tag == "2a" )
         M2as.forall( m => (
            & Quorum.exists( Q => V::ShowsSafeAt(Q, m.bal, m.value) )
            & M2as.forall( mm =>
                (mm.bal == m.bal) implies (mm.value == m.value)
              )
         ) )
       & V::Inv
)

}
