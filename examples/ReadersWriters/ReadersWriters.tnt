module ReadersWriters {
  /***************************************************************************)
  (* This solution to the readers-writers problem, cf.                       *)
  (* https://en.wikipedia.org/wiki/Readersâ€“writers_problem,                  *)
  (* uses a queue in order to fairly serve all requests.                     *)
  (***************************************************************************/
  const NumActors: int
  
  var readers: set(int)   // set of processes currently reading
  var writers: set(int)   // set of processes currently writing
  var waiting: list((str, int))  // queue of processes waiting to access the resource
  
  val vars = (readers, writers, waiting)
  
  val Actors = 1.to(NumActors)
  
  def ToSet(s) = s.indices().map(i => s[i])
  
  def read(s)  = s._1 == "read"
  def write(s) = s._1 == "write"
  
  val WaitingToRead  = ToSet(waiting.select(read)).map( p => p._2 )
  
  val WaitingToWrite = ToSet(waiting.select(write)).map( p => p._2 )
  
  //---------------------------------------------------------------------------
  
  /***********)
  (* Actions *)
  (***********/
  
  action TryRead(actor) = all {
      actor notin WaitingToRead,
      waiting <- waiting.append(("read", actor)),
  }
  
  action TryWrite(actor) = all {
      actor notin WaitingToWrite,
      waiting <- waiting.append(("write", actor)),
  }
  
  action Read(actor) = all {
      readers <- readers.union(set(actor)),
      waiting <- waiting.tail(),
  }
  
  action Write(actor) = all {
      readers == set(),
      writers <- writers.union(set(actor)),
      waiting <- waiting.tail(),
  }
  
  action ReadOrWrite = all {
      waiting != [],
      writers == set(),
      val pair = waiting.head()
      val actor = pair._2
      if (pair._1 == "read") all {
          Read(actor),
          writers <- writers,
      } else all { // pair._1 == "write"
          Write(actor),
          readers <- readers,
      }  
  }
  
  action StopActivity(actor) =
      if (actor in readers) all {
          readers <- readers.exclude(set(actor)),
          writers <- writers,
      } else all {
          writers <- writers.exclude(set(actor)),
          readers <- readers,
      }

  action Stop =
      readers.union(writers).guess({ actor => StopActivity(actor) })
  
  //---------------------------------------------------------------------------
  
  /*****************)
  (* Specification *)
  (*****************/
  
  action Init = all {
      readers == set(),
      writers == set(),
      waiting == []
  }
  
  action Next = any {
      all {
          Actors.guess({ actor => TryRead(actor) }),
          readers <- readers,
          writers <- writers
      },
      all {
          Actors.guess({ actor => TryWrite(actor) }),
          readers <- readers,
          writers <- writers
      },
      ReadOrWrite,
      all {
          Stop,
          waiting <- waiting
      },
  }
  
  temporal Fairness = and {
      Actors.forall(actor => TryRead(actor).weakFair(vars)),
      Actors.forall(actor => TryWrite(actor).weakFair(vars)),
      ReadOrWrite.weakFair(vars),
      Stop.weakFair(vars)
  }
  
  temporal Spec = Init and always(stutter(Next, vars) and Fairness)
  
  //---------------------------------------------------------------------------
  
  /**************)
  (* Invariants *)
  (**************/
  
  val TypeOK = and {
      readers.subseteq(Actors),
      writers.subseteq(Actors),
      waiting in tuples(ToSet(allLists(set("read", "write")).Actors))
  }
  
  val Safety = and {
      not(readers != set() and writers != set()),
      size(writers) <= 1
  }
  
  /**************)
  (* Properties *)
  (**************/
  
  temporal Liveness = and {
      Actors.forall(actor => always(eventually(actor in readers))),
      Actors.forall(actor => always(eventually(actor in writers))),
      Actors.forall(actor => always(eventually(actor notin readers))),
      Actors.forall(actor => always(eventually(actor notin writers))),
  }
}
