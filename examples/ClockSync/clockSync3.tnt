

// A translation of https://github.com/informalsystems/tla-apalache-workshop/blob/main/examples/clock-sync/ClockSync3.tla
// motivated by the discussion at https://github.com/informalsystems/tnt/discussions/144
module ClockSync3 {
    //// HELPERS

    // Add the element `e` to the set `s`
    def add(s, e): (Set[a], a) => Set[a] = s.union(Set(e))

    // NOTE: Sketch of something like "when foo do bar" within existing syntax
    //       to be used like `condition.allows {act1 & act2 & ...}`
    //       could also be named like `guard.when {actions...}` but I'm afraid
    //       it reads backwards
    // This is just an alias for "and", but with a restricted mode:
    //
    // mode allows = (Read[vars], Update[vars']) => Read[vars] & Update[vars']
    // TODO: This is currently not working due to mode checking errors.
    // action allows(condition, actn): (bool, bool) => bool = { condition & actn }
    

    //// CONSTANTS

    // minimum message delay
    const t_min : int
    // maximum message delay
    const t_max : int

    assume _ = (t_min >= 0 and t_max > t_min)


    //// TYPES AND CONSTRUCTORS

    // The type of processes
    type proc = {id : int}

    // Construct a process
    def Proc(id) : (int) => {id : int} = { id : id }

    // Control states
    // TODO: We'd actually like a sum type for this
    type state = str

    // The type for a message sent by a process
    type msg = {src : proc, ts: int}

    def msgFrom(p, ts) = {src: p, ts : ts}

    // The type for a set of messages
    type msgs = Set[msg]


    //// STATE

    // The reference clock, inaccessible to the processes
    var time: int

    // Hardware clock of a process
    var hc: proc -> int

    // Clock adjustment of a process
    var adj: proc -> int

    // Messages sent by the processes
    var msgs: msgs

    // Messages received by the processes
    var rcvd: proc -> msgs

    // The control state of a process
    var state: proc -> state


    /// DEFINITIONS

    // We fix the model to contain two processes
    val Procs : Set[proc] = set(Proc(1), Proc(2))

    // The set of possible control states
    val states : Set[state] = set("init", "sent", "sync")


    //// INITIALIZATION

    // a nice to have syntax form:
    //action selectFrom(v, s) = s.guess(x => v <- x)

    action Init = all {
        { nondet time0 = oneOf(Nat)
          time' = time0 },
        { nondet hc0 = oneOf(setOfMaps(Procs, Nat))
          hc' = hc0 },
        adj'   = Procs.mapBy(_ => 0),
        state' = Procs.mapBy(_ => "init"),
        msgs'  = Set(),
        rcvd'  = Procs.mapBy(_ => Set()),
    }

    //// ACTIONS

    // Send the value of the hardware clock
    // TODO: action<msgs, state> ...
    action sendMsg(p) = all {
        state[p] == "init",
        msgs'  = msgs.add(p.msgFrom(hc[p])),
        state' = state.set(p, "sent"),
        rcvd'  = rcvd,
    }
    
    // Receive a message sent by another process
    // TODO: action<rcvd> ...
    action receiveMsg(p) = {
        msgs.guess( newMsg => all {
            newMsg.notin(rcvd[p]),
            // the message cannot be received earlier than after t_min
            hc[newMsg.src] >= newMsg.ts + t_min,
            rcvd <- rcvd.set(p, rcvd[p].add(newMsg)),
            state <- state,
            msgs <- msgs,
        })
    }

    // let time flow
    // TODO: action<time, hc>
    action advanceClocks(delta) = all {
        delta > 0,
        // clocks can be advanced only if there are no pending message
        msgs.forall(m => 
            (hc[m.src] + delta > t_max)
            .implies(
                Procs.forall(p => m.in(rcvd[m.src])))),
        time' = time + delta,
        hc'   = Procs.mapBy(p => hc[p] + delta),
    }

    //// TRANSITIONS

    action Next = any {
        all {
            msgs <- msgs,
            state <- state,
            rcvd <- rcvd,
            Int.guess(advanceClocks),
        },
        all {
            time <- time,
            hc <- hc,
            { nondet p = oneOf(Procs)
              any {
                sendMsg(p),
                receiveMsg(p),
              }
            }
        }
    }
}
