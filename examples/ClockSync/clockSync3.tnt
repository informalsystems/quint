

// A translation of https://github.com/informalsystems/tla-apalache-workshop/blob/main/examples/clock-sync/ClockSync3.tla
// motivated by the discussion at https://github.com/informalsystems/tnt/discussions/144
module ClockSync3 {
    //// HELPERS

    // Add the element `e` to the set `s`
    def add(s, e): (set(a), a) => set(a) = s.union(set(e))

    // NOTE: Sketch of something like "when foo do bar" within existing syntax
    //       to be used like `condition.allows {act1 & act2 & ...}`
    //       could also be named like `guard.when {actions...}` but I'm afraid
    //       it reads backwards
    // This is just an alias for "and", but with a restricted mode:
    //
    // mode allows = (Read[vars], Update[vars']) => Read[vars] & Update[vars']
    // TODO: This is currently not working due to mode checking errors.
    // action allows(condition, actn): (bool, bool) => bool = { condition & actn }
    

    //// CONSTANTS

    // minimum message delay
    const t_min : int
    // maximum message delay
    const t_max : int

    assume _ = (t_min >= 0 and t_max > t_min)


    //// TYPES AND CONSTRUCTORS

    // The type of processes
    type proc = {id : int}

    // Construct a process
    def Proc(id) : int -> proc = { id : id }

    // Control states
    // TODO: We'd actually like a sum type for this
    type state = str

    // The type for a message sent by a process
    type msg = {src : proc, ts: int}

    def msgFrom(p, ts) = {src: p, ts : ts}

    // The type for a set of messages
    type msgs = set(msg)


    //// STATE

    // The reference clock, inaccessible to the processes
    var time: int

    // Hardware clock of a process
    var hc: proc -> int

    // Clock adjustment of a process
    var adj: proc -> int

    // Messages sent by the processes
    var msgs: msgs

    // Messages received by the processes
    var rcvd: proc -> msgs

    // The control state of a process
    var state: proc -> state


    /// DEFINITIONS

    // We fix the model to contain two processes
    val Procs : set(proc) = set(Proc(1), Proc(2))

    // The set of possible control states
    val states : set(state) = set("init", "sent", "sync")


    //// INITIALIZATION

    // a nice to have syntax form:
    //action selectFrom(v, s) = s.guess(x => v <- x)

    action Init = all {
        time.selectFrom(Nat),
        hc.selectFrom(setOfMaps(Procs, Nat)),
        adj   <- Procs.mapOf(_ => 0),
        state <- Procs.mapOf(_ => "init"),
        msgs  <- set(),
        rcvd  <- Procs.mapOf(_ => set()),
    }

    //// ACTIONS

    // Send the value of the hardware clock
    // TODO: action<msgs, state> ...
    action sendMsg(p) = all {
        state[p] == "init",
        msgs  <- msgs.add(p.msgFrom(hc[p])),
        state <- state.update(p, "sent"),
        rcvd  <- rcvd,
    }
    
    // Receive a message sent by another process
    // TODO: action<rcvd> ...
    action receiveMsg(p) = {
        msgs.guess( newMsg => all {
            newMsg.notin(rcvd[p]),
            // the message cannot be received earlier than after t_min
            hc[newMsg.src] >= newMsg.ts + t_min,
            rcvd <- rcvd.update(p, rcvd[p].add(newMsg)),
            state <- state,
            msgs <- msgs,
        })
    }

    // let time flow
    // TODO: action<time, hc>
    action advanceClocks(delta) = all {
        delta > 0,
        // clocks can be advanced only if there are no pending message
        msgs.forall( m => hc[m.src] + delta > t_max implies
                Procs.forall( p => m in rcvd[m.src] )),
        time <- time + delta,
        hc   <- Procs.mapOf(p => hc[p] + delta),
    }

    //// TRANSITIONS

    action Next = any {
        all {
            msgs <- msgs,
            state <- state,
            rcvd <- rcvd,
            Int.guess(advanceClocks),
        },
        all {
            time <- time,
            hc <- hc,
            Procs.guess(p => or any {
                sendMsg(p),
                receiveMsg(p),
            })
        }
    }
}
