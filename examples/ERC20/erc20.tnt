module erc20 {
  type ADDR = str
  type TX = {
    tag: str,
    id: int,
    fail: bool,
    sender: ADDR,
    spender: ADDR,
    fromAddr: ADDR,
    toAddr: ADDR,
    value: int
  }

  const ADDR: set(ADDR)
  const AMMOUNTS: set(int)

  var balanceOf: ADDR -> int
  var allowance: (ADDR, ADDR) -> int

  var pendingTransactions: set(TX)
  var lastTx: TX
  var nextTxId: int

  action Init = all {
    balanceOf <- ADDR.mapBy(_ => 100),
    allowance <- tuples(ADDR, ADDR).mapBy(_ => 0),
    pendingTransactions <- set(),
    nextTxId <- 0,
    lastTx <- { id: 0, tag: "none", fail: false }
  }

  /* EIP-20:
  The following action submits a transaction to the blockchain.

  Transfers value amount of tokens to address toAddr, and MUST fire the Transfer
  event. The function SHOULD throw if the message callerâ€™s account balance does
  not have enough tokens to spend.

  Note Transfers of 0 values MUST be treated as normal transfers and fire the
  Transfer event.
  */
  action SubmitTransfer(sender, toAddr, value) = {
    val newTx = { id: nextTxId, tag: "transfer", fail: false, 
                  sender: sender, toAddr: toAddr, value: value }
    all {
      pendingTransactions <- pendingTransactions.union(set(newTx)),
      lastTx <- { id: 0, tag: "none", fail: false },
      nextTxId <- nextTxId + 1,
      balanceOf <- balanceOf,
      allowance <- allowance,
    }
  }

  /* Process a Transfer transaction that was submitted with SubmitTransfer. */
  action CommitTransfer(tx) = all {
    tx.tag == "transfer",
    pendingTransactions <- pendingTransactions.exclude(set(tx)),
    allowance <- allowance,
    nextTxId <- nextTxId,
    val fail = or { 
     tx.value < 0,
     tx.value > balanceOf[tx.sender],
     tx.sender == tx.toAddr
    } all {
      lastTx <- tx.with("fail", fail),
      if (fail) 
        balanceOf <- balanceOf
      else
        balanceOf <- balanceOf
                       .updateAs(tx.sender, v => v - tx.value)
                       .updateAs(tx.toAddr, v => v + tx.value)
    },
  }

  /* EIP-20:
  Transfers value amount of tokens from address fromAddr to address toAddr, and
  MUST fire the Transfer event.

  The transferFrom method is used for a withdraw workflow, allowing contracts to
  transfer tokens on your behalf. This can be used for example to allow a
  contract to transfer tokens on your behalf and/or to charge fees in
  sub-currencies. The function SHOULD throw unless the fromAddr account has
  deliberately authorized the sender of the message via some mechanism.

  Note Transfers of 0 values MUST be treated as normal transfers and fire the
  Transfer event.
  */
  action SubmitTransferFrom(sender, fromAddr, toAddr, value) = {
    val newTx = { id: nextTxId, tag: "transferFrom", fail: false, sender: sender,
                  fromAddr: fromAddr, toAddr: toAddr, value: value }
    all {
      pendingTransactions <- pendingTransactions.union(set(newTx)),
      lastTx <- { id: 0, tag: "none", fail: false },
      nextTxId <- nextTxId + 1,
      balanceOf <- balanceOf,
      allowance <- allowance,
    }
  }

  /* Process a TransferFrom transaction that was submitted with SubmitTransferFrom. */
  action CommitTransferFrom(tx) = all {
    tx.tag == "transferFrom",
    pendingTransactions <- pendingTransactions.exclude(set(tx)),
    nextTxId <- nextTxId,
    val fail = or {
     tx.value < 0,
     tx.value > balanceOf[tx.fromAddr],
     tx.value > allowance[(tx.fromAddr, tx.sender)],
     tx.fromAddr == tx.toAddr
    } all {
      lastTx <- tx.with("fail", fail),
      if (fail)
        all {
          balanceOf <- balanceOf,
          allowance <- allowance,
        }
      else
        all {
          balanceOf <- balanceOf
                         .updateAs(tx.fromAddr, v => v - tx.value)
                         .updateAs(tx.toAddr, v => v + tx.value),
          allowance <- allowance.updateAs((tx.fromAddr, tx.sender), v => v - tx.value),
        },
    },
  }

  /* EIP-20:
  Allows spender to withdraw from your account multiple times, up to the _value
  amount. If this function is called again it overwrites the current allowance
  with _value.
  */
  action SubmitApprove(sender, spender, value) = {
    val newTx = { id: nextTxId, tag: "approve", fail: false,
                  sender: sender, spender: spender, value: value }
    all {
      pendingTransactions <- pendingTransactions.union(set(newTx)),
      lastTx <- { id: 0, tag: "none", fail: false },
      nextTxId <- nextTxId + 1,
      balanceOf <- balanceOf,
      allowance <- allowance,
    }
  }

  /* Process an Approve transaction that was submitted with SubmitApprove. */
  action CommitApprove(tx) = all {
    tx.tag == "approve",
    pendingTransactions <- pendingTransactions.exclude(set(tx)),
    nextTxId <- nextTxId,
    balanceOf <- balanceOf,
    val fail = or {
     tx.value < 0,
     tx.sender > tx.spender,
    } all {
      lastTx <- tx.with("fail", fail),
      if (fail)
        allowance <- allowance
      else
        allowance <- allowance.update((tx.sender, tx.spender), tx.value)
    },
  }

  /* The transition relation, which chooses one of the actions */
  action Next = any {
    ADDR.guess(sender =>
      ADDR.guess(toAddr =>
        AMMOUNTS.guess(value =>
          SubmitTransfer(sender, toAddr, value)
        )
      )
    ),
    ADDR.guess(sender =>
      ADDR.guess(fromAddr =>
        ADDR.guess(toAddr =>
          AMMOUNTS.guess(value =>
            SubmitTransferFrom(sender, fromAddr, toAddr, value)
          )
        )
      )
    ),
    ADDR.guess(sender =>
      ADDR.guess(spender =>
        AMMOUNTS.guess(value =>
          SubmitApprove(sender, spender, value)
        )
      )
    ),
    pendingTransactions.guess(tx =>
      any {
        CommitTransfer(tx),
        CommitTransferFrom(tx),
        CommitApprove(tx),
      }
    )
  }

  /* False invariants to debug the spec */

  /* Claim that no `TransferFrom` transaction is ever processed.
    This is false. Use this false invariant to see an example of how
    `TransferFrom` is processed. */

  val NoTransferFrom =
    val example = all {
      lastTx.tag == "transferFrom",
      not(lastTx.fail),
      lastTx.value > 0,
    }

    not(example)


  /* Claim that no `Approve` transaction is ever processed.
    This is false. Use this false invariant to see an example of how
    `Approve` is processed. */

  val NoApprove =
    val example = all {
      lastTx.tag == "approve",
      not(lastTx.fail),
      lastTx.value > 0,
    }

    not(example)

  /* EXPECTED PROPERTIES */

  /* No transferFrom should be possible, while there is a pending approval
    for a smaller amount. This invariant is violated, as explained in:
    https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit# */

  val NoTransferFromWhileApproveInFlight =
    val badExample = all {
      lastTx.tag == "transferFrom",
      lastTx.value > 0,
      not(lastTx.fail),
      pendingTransactions.guess(tx =>
        all {
          tx.tag == "approve",
          tx.sender == lastTx.fromAddr,
          tx.spender == lastTx.sender,
          tx.value < lastTx.value,
          tx.value > 0,
        }
      )
    }
    not(badExample)

  /* Make sure that the account balances never go negative. */
  val NoNegativeBalances = ADDR.forall(a => balanceOf[a] >= 0)
}
